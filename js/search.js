// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Assert steps",
      "url": "/cornichon/custom-steps/assert-step.html",
      "content": "AssertStep An AssertStep can be understood as the following function ScenarioContext =&gt; Assertion. Its goal is to describe an expectation. The test engine is responsible to test the validity of the provided Assertion which can be one of the following: Equality assertions : test the equality of two objects using the cats Equals typeclass. GenericEqualityAssertion to leave all the details to Cornichon When I AssertStep(\"always true!\", _ =&gt; GenericEqualityAssertion(true, true)) CustomMessageEqualityAssertion to provide a custom error message CustomMessageAssertion[A](expected: A, result: A, customMessage: () ⇒ String) Ordering assertions : compare two objects using the cats Order typeclass. GreaterThanAssertion LessThanAssertion BetweenAssertion Collection assertions : test the state of a collection of elements CollectionEmptyAssertion CollectionNotEmptyAssertion CollectionSizeAssertion CollectionContainsAssertion String assertion : assert the content of a given String value StringContainsAssertion RegexAssertion Below is a longer example showing how to integrate an assertion into a scenario. When I EffectStep.fromSync( title = \"estimate PI\", action = scenarioContext =&gt; scenarioContext.session.add(\"result\", piComputation()) ) Then assert AssertStep( title = \"check estimate\", action = scenarioContext =&gt; Assertion.either{ scenarioContext.session.get(\"result\").map(r =&gt; BetweenAssertion(3.1, r.toDouble, 3.2)) } ) Assertions can also be composed using and and or, for instance BetweenAssertion is the result of LessThanAssertion and GreaterThanAssertion. This is rather low level therefore you should not write your steps like that directly inside the DSL but hide them behind functions with appropriate names. Fortunately a bunch of built-in steps and primitive building blocks are already available for you. Note for advance users: it is also possible to write custom wrapper steps by implementing WrapperStep."
    } ,    
    {
      "title": "Basics",
      "url": "/cornichon/basics.html",
      "content": "Basics A Cornichon test is the definition of a so-called feature. Concretely it is a class extending CornichonFeature and implementing the required feature function. In the case of SBT, those classes live inside src/test/scala and can be run them using sbt test. A feature can have several scenarios which in turn can have several steps. The example below contains one feature with one scenario with two steps. import com.github.agourlay.cornichon.CornichonFeature class CornichonExamplesSpec extends CornichonFeature { def feature = Feature(\"Checking google\"){ Scenario(\"Google is up and running\"){ When I get(\"http://google.com\") Then assert status.is(302) } } } The failure modes are the following: A feature fails if one or more scenarios fail. A scenario fails if at least one step fails. A scenario will stop at the first failed step encountered and ignore the remaining steps."
    } ,    
    {
      "title": "Custom steps",
      "url": "/cornichon/custom-steps.html",
      "content": "Custom steps When the built-in steps of Cornichon are not enough for what you want to express, it is time to write your own custom steps. There are currently 4 kinds of custom steps available EffectStep AssertStep ResourceStep WrapperStep"
    } ,    
    {
      "title": "DSL",
      "url": "/cornichon/dsl.html",
      "content": "DSL The content of a feature is described using a domain-specific language (DSL) providing a clear structure for statement definitions. The structure of a step statement is the following: 1 - starts with either Given - When - And - Then The prefixes do not change the behavior of the steps but are present to improve the readability. 2 - followed by any single word (could be several words wrapped in back-ticks) This structure was chosen to increase the freedom of customization while still benefiting from Scala’s infix notation. 3 - ending with a step definition The usage pattern is often to first run a step with a side effect then assert an expected state in a second step. For example : Given I step_definition When a step_definition And \\`another really important\\` step_definition Then assert step_definition step_definition stands here for any object of type Step, those can be manually defined or simply built-in in Cornichon. Built-in steps Cornichon has a set of built-in steps for various HTTP calls and assertions on the response. HTTP effects GET, DELETE, HEAD, OPTIONS, POST, PUT and PATCH use the same request builder for request’s body, URL parameters and headers. head(\"http://superhero.io/daredevil\") get(\"http://superhero.io/daredevil\").withParams( \"firstParam\" -&gt; \"value1\", \"secondParam\" -&gt; \"value2\") delete(\"http://superhero.io/daredevil\").withHeaders((\"Authorization\", \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")) post(\"http://superhero.io/batman\").withBody(\"JSON description of Batman goes here\") put(\"http://superhero.io/batman\").withBody(\"JSON description of Batman goes here\").withParams( \"firstParam\" -&gt; \"value1\", \"secondParam\" -&gt; \"value2\") patch(\"http://superhero.io/batman\").withBody(\"JSON description of Batman goes here\") There is a built-in support for HTTP body defined as String, if you wish to use other types please check out the section Custom HTTP body type. HTTP assertions assert response status status.is(200) assert response headers headers.name(\"cache-control\").isPresent headers.contain(\"cache-control\" -&gt; \"no-cache\") headers.name(\"cache_control\").isAbsent save_header_value(\"cache_control\" -&gt; \"my-cache-control-value\") assert response body comes with different flavors (ignoring, whitelisting) body.is( \"\"\" { \"name\": \"Batman\", \"realName\": \"Bruce Wayne\", \"city\": \"Gotham city\", \"hasSuperpowers\": false, \"publisher\":{ \"name\":\"DC\", \"foundationYear\":1934, \"location\":\"Burbank, California\" } } \"\"\") body.ignoring(\"city\", \"hasSuperpowers\", \"publisher.foundationYear\", \"publisher.location\").is( \"\"\" { \"name\": \"Batman\", \"realName\": \"Bruce Wayne\", \"publisher\":{ \"name\":\"DC\" } } \"\"\") body.whitelisting.is( \"\"\" { \"name\": \"Batman\", \"realName\": \"Bruce Wayne\", \"publisher\":{ \"name\":\"DC\" } } \"\"\") Ignored keys and extractors are JsonPaths following the format “a.b.c[index].d”. The index value is either: an Integer addressing the array position. a * to target all values, the result will be an array of the projected values. JsonPath can also be used to only assert part of the response body.path(\"city\").is(\"Gotham city\") body.path(\"hasSuperpowers\").is(false) body.path(\"publisher.name\").is(\"DC\") body.path(\"city\").containsString(\"Gotham\") body.path(\"superheroes[*].name\").is(\"\"\"[ \"Spiderman\", \"IronMan\", \"Superman\", \"GreenLantern\", \"Batman\" ]\"\"\") body.path(\"publisher.foundationYear\").is(1934) body.path(\"publisher.foundationYear\").isPresent body.path(\"publisher.foundationMonth\").isAbsent It is possible to handle null values, given the following response body { “data” : null } body.path(\"data\").isAbsent //incorrect body.path(\"data\").isPresent //correct body.path(\"data\").isNull //correct body.path(\"data\").isNotNull //incorrect If one key of the path contains a “.” it has to be wrapped with “`” to notify the parser. body.path(\"`message.en`\").isPresent body.path(\"`message.fr`\").isAbsent To address a root array use $ followed by the index the access. body.path(\"$[2].name\") If the endpoint returns a collection assert response body has several options (ordered, ignoring and using data table) body.asArray.inOrder.ignoringEach(\"city\", \"hasSuperpowers\", \"publisher\").is( \"\"\" [{ \"name\": \"Batman\", \"realName\": \"Bruce Wayne\" }, { \"name\": \"Superman\", \"realName\": \"Clark Kent\" }] \"\"\") body.asArray.inOrder.ignoringEach(\"publisher\").is( \"\"\" | name | realName | city | hasSuperpowers | | \"Batman\" | \"Bruce Wayne\" | \"Gotham city\" | false | | \"Superman\" | \"Clark Kent\" | \"Metropolis\" | true | \"\"\") body.asArray.hasSize(2) body.asArray.size.is(2) //equivalent to above body.asArray.size.isLesserThan(3) body.asArray.size.isGreaterThan(1) body.asArray.size.isBetween(1, 3) body.asArray.isNotEmpty body.asArray.contains( \"\"\" { \"name\": \"Batman\", \"realName\": \"Bruce Wayne\", \"city\": \"Gotham city\", \"hasSuperpowers\": false, \"publisher\":{ \"name\":\"DC\", \"foundationYear\":1934, \"location\":\"Burbank, California\" } } \"\"\") It is important to mention that body expects a JSON content! When receiving non JSON payloads, use body_raw which offers String like assertions. body_raw.containsString(\"xml\") HTTP streams Server-Sent-Event. When I open_sse(s\"http://superhero.io/stream\", takeWithin = 1.seconds).withParams(\"justName\" -&gt; \"true\") Then assert body.asArray.hasSize(2) Then assert body.is(\"\"\" | eventType | data | id | retry | comment | | \"superhero name\" | \"Batman\" | null | null | null | | \"superhero name\" | \"Superman\" | null | null | null | \"\"\") SSE streams are aggregated over a period of time in an array, therefore the previous array predicates can be re-used. GraphQL support Cornichon offers an integration with the library Sangria to propose convenient features to test GraphQL API. GraphQL query import sangria.macros._ When I query_gql(\"/&lt;project-key&gt;/graphql\").withQuery( graphql\"\"\" query MyQuery { superheroes { results { name realName publisher { name } } } } \"\"\" ) query_gql can also be used for mutation query. GraphQL JSON all built-in steps accepting String input/output can also accept an alternative lightweight JSON format using the gqljson StringContext. import com.github.agourlay.cornichon.json.CornichonJson._ And assert body.ignoring(\"city\", \"publisher\").is( gqljson\"\"\" { name: \"Batman\", realName: \"Bruce Wayne\", hasSuperpowers: false } \"\"\") Session steps setting a value in session save(\"favorite-superhero\" -&gt; \"Batman\") saving value to session save_body_path(\"city\" -&gt; \"batman-city\") asserting value in session session_value(\"favorite-superhero\").is(\"Batman\") asserting JSON value in session session_value(\"my-json-response\").asJson.path(\"a.b.c\").ignoring(\"d\").is(\"...\") asserting existence of value in session session_value(\"favorite-superhero\").isPresent session_value(\"favorite-superhero\").isAbsent transforming a value in session transform_session(\"my-key\")(_.toUpperCase) Wrapper steps Wrapper steps allow to control the execution of a series of steps to build more powerful tests. repeating a series of steps Repeat(3) { When I get(\"http://superhero.io/batman\") Then assert status.is(200) } repeating a series of steps during a period of time RepeatDuring(300.millis) { When I get(\"http://superhero.io/batman\") Then assert status.is(200) } repeat a series of steps for each input element RepeatWith(\"Superman\", \"GreenLantern\", \"Spiderman\")(\"superhero-name\") { When I get(\"/superheroes/&lt;superhero-name&gt;\").withParams(\"sessionId\" -&gt; \"&lt;session-id&gt;\") Then assert status.is(200) Then assert body.path(\"hasSuperpowers\").is(true) } retry a series of steps until it succeeds or reaches the limit RetryMax(3) { When I get(\"http://superhero.io/batman\") Then assert status.is(200) } repeating a series of steps until it succeeds over a period of time at a specified interval (handy for eventually consistent endpoints) Eventually(maxDuration = 15.seconds, interval = 200.milliseconds) { When I get(\"http://superhero.io/random\") Then assert body.ignoring(\"hasSuperpowers\", \"publisher\").is( \"\"\" { \"name\": \"Batman\", \"realName\": \"Bruce Wayne\", \"city\": \"Gotham city\" } \"\"\" ) } It is also possible to enable the oscillation detector to fail the step in case of oscillation of errors. Given I send_async_command_updating_search_index Eventually(maxDuration = 1.seconds, interval = 100.ms, oscillationAllowed = false) { Given I search_for_new_state Then assert status.is(200) } Here an oscillation could be seen in the status with something like 404 -&gt; 500 -&gt; 404 -&gt; 200. execute a series of steps ‘n’ times by batch of p in parallel and wait ‘maxTime’ for completion. RepeatConcurrently(times = 10, parallel = 3, maxTime = 10 seconds) { When I get(\"http://superhero.io/batman\") Then assert status.is(200) } execute each step in parallel and wait ‘maxTime’ for completion. Concurrently(maxTime = 10 seconds) { When I get(\"http://superhero.io/batman\") When I get(\"http://superhero.io/superman\") } execute a series of steps and fails if the execution does not complete within ‘maxDuration’. Within(maxDuration = 10 seconds) { When I get(\"http://superhero.io/batman\") Then assert status.is(200) } repeat a series of steps with different inputs specified via a data-table WithDataInputs( \"\"\" | a | b | c | | 1 | 3 | 4 | | 7 | 4 | 11 | | 1 | -1 | 0 | \"\"\" ) { Then assert a_plus_b_equals_c } def a_plus_b_equals_c = AssertStep(\"sum of 'a' + 'b' = 'c'\", s ⇒ GenericEqualityAssertion(s.getUnsafe(\"a\").toInt + s.getUnsafe(\"b\").toInt, s.getUnsafe(\"c\").toInt)) WithHeaders automatically sets headers for several steps useful for an authenticated scenario. WithHeaders((\"Authorization\", \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\")){ When I get(\"http://superhero.io/secured\") Then assert status.is(200) } WithBasicAuth automatically sets basic auth headers for several steps. WithBasicAuth(\"admin\", \"root\"){ When I get(\"http://superhero.io/secured\") Then assert status.is(200) } HttpListenTo creates an HTTP server that will be running during the length of the enclosed steps. This feature is defined the module cornichon-http-mock and requires to extend the trait HttpMockDsl. By default, this server responds with 201 to any POST request and 200 for all the rest. Additionally, it provides three administrations features: fetching recorded received requests resetting recorded received requests toggling on/off the error mode to return HTTP 500 to incoming requests The server records all requests received as a JSON array of HTTP request for later assertions. There are two ways to perform assertions on the server statistics, either by querying the session at the end of the block or by contacting directly the server while it runs. Refer to those examples for more information. This feature is experimental and may change in the future. Log duration By default, all Step execution time can be found in the logs, but sometimes one needs to time a series of steps. This is where LogDuration comes in handy, it requires a label that will be printed as well to identify results. LogDuration(label = \"my experiment\") { When I get(\"http://superhero.io/batman\") Then assert status.is(200) } Debug steps showing session content for debugging purpose And I show_session And I show_last_response And I show_last_response_json (pretty print the json body) And I show_last_status And I show_last_body And I show_last_body_json (pretty print the json body) And I show_last_headers Those descriptions might be already outdated, in case of doubt always refer to those examples as they are executed as part of Cornichon’s test suite. DSL composition Series of steps defined with Cornichon’s DSL can be reused within different Scenarios. Using the keyword Attach if the series starts with a Step and without if it starts with a wrapping bloc. import com.github.agourlay.cornichon.CornichonFeature import scala.concurrent.duration._ class CompositionFeature extends CornichonFeature { def feature = Feature(\"Cornichon feature example\") { Scenario(\"demonstrate DSL composition\") { Then assert superhero_exists(\"batman\") Then assert random_superheroes_until(\"Batman\") } } def superhero_exists(name: String) = Attach { When I get(s\"/superheroes/$name\").withParams(\"sessionId\" -&gt; \"&lt;session-id&gt;\") Then assert status.is(200) } def random_superheroes_until(name: String) = Eventually(maxDuration = 3.seconds, interval = 10.milliseconds) { When I get(\"/superheroes/random\").withParams(\"sessionId\" -&gt; \"&lt;session-id&gt;\") Then assert body.path(\"name\").is(name) Then I print_step(\"bingo!\") } } It is possible to give a title to an attached bloc using AttachAs(title)."
    } ,    
    {
      "title": "Effect steps",
      "url": "/cornichon/custom-steps/effect-step.html",
      "content": "EffectStep An EffectStep can be understood as the following function ScenarioContext =&gt; Future[Either[CornichonError, Session]]. This means that an EffectStep runs a side effect and populates the Session with potential result values or returns an error. A Session is a Map-like object used to propagate state throughout a scenario. It is used to resolve placeholders and save the result computations for later assertions. Here is the simplest EffectStep possible: When I EffectStep(title = \"do nothing\", action = scenarioContext =&gt; Future.successful(Right(scenarioContext.session))) or using a factory helper when dealing with computations that do not fit the EffectStep type. When I EffectStep.fromSync(title = \"do nothing\", action = scenarioContext =&gt; scenarioContext.session) When I EffectStep.fromSyncE(title = \"do nothing\", action = scenarioContext =&gt; Right(scenarioContext.session)) When I EffectStep.fromAsync(title = \"do nothing\", action = scenarioContext =&gt; Future(scenarioContext.session)) Let’s try to save a value into the Session When I EffectStep.fromSync(title = \"estimate PI\", action = scenarioContext =&gt; scenarioContext.session.add(\"result\", piComputation())) The test engine is responsible for controlling the execution of the side effect function and to report any error. If you prefer not using the scala.concurrent.Future as effect, it is possible to use the Effect type from cats-effect. import com.github.agourlay.cornichon.steps.cats.EffectStep val myTaskEffect = EffectStep(\"identity task\", scenarioContext =&gt; Task.now(Right(scenarioContext.session))) EffectStep using the HTTP service Sometimes you want to perform HTTP calls inside an EffectStep, this is where the httpService comes in handy. In order to illustrate its usage let’s take the following example, you would like to write a custom step like: def feature = Feature(\"Customer endpoint\") { Scenario(\"create customer\") { When I create_customer Then assert status.is(201) } } Most of the time you will create your own trait containing your custom steps and declare a self-type on CornichonFeature to be able to access the httpService. It exposes a method requestEffect turning an HttpRequest into an asynchronous effect. trait MySteps { this: CornichonFeature ⇒ def create_customer = EffectStep( title = \"create new customer\", effect = http.requestEffect( request = HttpRequest.post(\"/customer\").withPayload(\"someJson\"), expectedStatus = Some(201) extractor = RootExtractor(\"customer\") ) ) } The built-in HTTP steps available on the DSL are actually built on top of the httpService which means that you benefit from all the existing infrastructure to: resolve placeholders in URL, query params, body and headers. automatically populate the session with the results of the call such as response body, status and headers (it is also possible to pass a custom extractor). handle common errors such as timeout and malformed requests."
    } ,    
    {
      "title": "Feature options",
      "url": "/cornichon/feature-options.html",
      "content": "Feature options To implement a CornichonFeature it is only required to implement the feature function. However, a number of useful options are available using override. Before and after hooks Hooks are available to set up and tear down things as usual but this feature is not integrated into the DSL. Four functions are available in CornichonFeature with self-explanatory names: Taking a Unit expression beforeFeature { // do side effect here } afterFeature { // do side effect here } Taking a Step expression similar to the main DSL. You can either pass a single regular Step or a WrapperStep like Attach. Here is an examples with fictitious steps. beforeEachScenario { Attach { Given I setup_server Then assert setup_successful } } afterEachScenario{ Then I cleanup_resources } Base URL Instead of repeating at each HTTP statement the full URL, it is possible to set a common URL for the entire feature by overriding: override lazy val baseUrl = s\"http://localhost:8080\" and then only provide the missing part in the HTTP step definition When I get(\"/superheroes/Batman\") When I delete(\"/superheroes/GreenLantern\") You can still override the base URL of a single step by providing the complete URL starting with the HTTP protocol. Request timeout The default value for the HTTP request timeout is 2 seconds. As always it can be overridden per scenario. import scala.concurrent.duration._ override lazy val requestTimeout = 100.millis Seed On a failure the initial seed will be provided in the error reporting enabling you to replay the exact same test even if it contains source of randomness such as: randomized placeholders (random-uuid, random-string, random-boolean etc) property based testing generators &amp; transitions custom steps using ScenarioContext.randomContext RandomMapper as extractor override lazy val seed: Option[Long] = Some(1L) Register custom extractors In some cases it makes sense to declare extractors to avoid code duplication when dealing with session values. An extractor is responsible to describe using a JsonPath how to build a value from an existing value in session. For instance if most of your JSON responses contain a field id and you want to use it as a placeholder without always having to manually extract and save the value into the session you can write : override def registerExtractors = Map( \"response-id\" -&gt; JsonMapper(HttpService.LastResponseBodyKey, \"id\") ) It is now possible to use &lt;response-id&gt; or &lt;response-id[integer]&gt; in the steps definitions. It works for all keys in Session, let’s say we also have objects registered under keys customer &amp; product: override def registerExtractors = Map( \"response-version\" -&gt; JsonMapper(HttpService.LastResponseBodyKey, \"version\"), \"customer-street\" -&gt; JsonMapper(\"customer\", \"address.street\"), \"product-first-rating\" -&gt; JsonMapper(\"product\", \"rating[0].score\") ) Execution model By default, the features are executed sequentially and the scenarios within are executed in parallel. This execution is configurable if you have specific constraints. To run scenarios sequentially it is necessary to declare in your application.conf file cornichon { executeScenariosInParallel = false } The actual number of concurrent scenario is controlled via the configuration field scenarioExecutionParallelismFactor which defaults to 1. number of concurrent scenarios = `scenarioExecutionParallelismFactor` * number of CPU + 1 This means using more powerful machines will automatically trigger more scenarios. To run features in parallel it is necessary to manually set a flag in your SBT build file. parallelExecution in Test := true or through the command line sbt test parallelExecution in Test := true Ignoring features or scenarios Feature or individual scenario can also be marked to be ignored. import com.github.agourlay.cornichon.CornichonFeature class CornichonExamplesSpec extends CornichonFeature { // Ignore a complete feature def feature = Feature(\"Checking google\").ignoredBecause(\"Your reasons ...\"){ // Ignore a single scenario Scenario(\"Google is up and running\").ignoredBecause(\"Your reasons ...\"){ When I get(\"http://google.com\") Then assert status.is(302) } } } Pending scenario During development, you may want to remember that a scenario needs to be created, but you’re not ready to write it yet. import com.github.agourlay.cornichon.CornichonFeature class CornichonPendingExamplesSpec extends CornichonFeature { def feature = Feature(\"Some title\"){ Scenario(\"this important use case\").pending Scenario(\"that important edge case\").pending } }"
    } ,    
    {
      "title": "ForAll",
      "url": "/cornichon/pbt/for-all.html",
      "content": "ForAll The first flavour follows the classical approach found in many testing libraries. That is, for any values from a set of generators, we will validate that a given invariant holds. Here is the API available when using a single generator def for_all[A](description: String, ga: RandomContext ⇒ Generator[A])(f: A ⇒ Step): Step Let’s look at an example to see how to use it! We want to enforce the following invariant for any string, if we reverse it twice, it should yield the same value. The implementation under test is a server accepting POST requests to /double-reverse with a query param named word will return the given word reversed twice. import com.github.agourlay.cornichon.core._ import com.github.agourlay.cornichon.CornichonFeature class StringReverseCheck extends CornichonFeature { def feature = Feature(\"Basic examples of checks\") { Scenario(\"reverse a string twice yields the same results\") { Given check for_all(\"reversing twice a string yields the same result\", maxNumberOfRuns = 5, stringGen) { randomString =&gt; Attach { Given I post(\"/double-reverse\").withParams(\"word\" -&gt; randomString) Then assert status.is(200) Then assert body.is(randomString) } } } } def stringGen(rc: RandomContext): ValueGenerator[String] = ValueGenerator( name = \"alphanumeric String (20)\", gen = () =&gt; rc.alphanumeric(20)) } To understand what is going on, we can have a look at the logs produced by this scenario. Starting scenario 'reverse a string twice yields the same results' - reverse a string twice yields the same results (1848 millis) Scenario : reverse a string twice yields the same results main steps ForAll 'alphanumeric String (20)' check 'reversing twice a string yields the same result' with maxNumberOfRuns=5 and seed=1542985803071 Run #0 Given I POST /double-reverse with query parameters 'word' -&gt; 'vtKxhkCJaVlAOzhdSCwD' (1257 millis) Then assert status is '200' (7 millis) Then assert response body is vtKxhkCJaVlAOzhdSCwD (32 millis) Run #0 Run #1 Given I POST /double-reverse with query parameters 'word' -&gt; '1bmmb2urTfJy59J2gGtI' (5 millis) Then assert status is '200' (0 millis) Then assert response body is 1bmmb2urTfJy59J2gGtI (0 millis) Run #1 Run #2 Given I POST /double-reverse with query parameters 'word' -&gt; 'Fg3Dzp61as7Pkvvj49ub' (5 millis) Then assert status is '200' (0 millis) Then assert response body is Fg3Dzp61as7Pkvvj49ub (0 millis) Run #2 Run #3 Given I POST /double-reverse with query parameters 'word' -&gt; 'bDLbxzMjMgVUP1iRLu4c' (5 millis) Then assert status is '200' (0 millis) Then assert response body is bDLbxzMjMgVUP1iRLu4c (0 millis) Run #3 Run #4 Given I POST /double-reverse with query parameters 'word' -&gt; 'byV6Azexsl1AcdatquSJ' (5 millis) Then assert status is '200' (0 millis) Then assert response body is byV6Azexsl1AcdatquSJ (0 millis) Run #4 Run #5 Given I POST /double-reverse with query parameters 'word' -&gt; 'pKGqRrbjUV7oMaPJzTJS' (4 millis) Then assert status is '200' (0 millis) Then assert response body is pKGqRrbjUV7oMaPJzTJS (0 millis) Run #5 ForAll 'alphanumeric String (20)' check 'reversing twice a string yields the same result' block succeeded (1846 millis) The logs show that: the string generator has been called for each run no invariants have been broken The source for the test and the server are available here. More often than not, using forAll is enough to cover the most common use cases. But sometimes we not only want to have random values generated but also random interactions with the system under tests."
    } ,    
    {
      "title": "Generators",
      "url": "/cornichon/pbt/generators.html",
      "content": "Generators At the center of property based testing lies the capacity to generate arbitrary values that will be used to verify if a given invariant holds. A generator is simply a function that accepts a RandomContext which is propagated throughout the execution, for instance below is an example generating Strings and Integers. There are tree concrete instances of generators: ValueGenerator SessionValueGenerator which provides additionally the Session OptionalValueGenerator to fail in a controlled fashion def stringGen(rc: RandomContext): ValueGenerator[String] = ValueGenerator( name = \"an alphanumeric String (20)\", gen = () ⇒ rc.alphanumeric(20)) def integerGen(rc: RandomContext): ValueGenerator[Int] = ValueGenerator( name = \"integer\", gen = () ⇒ rc.nextInt(10000)) This approach also supports embedding Scalacheck's Gen into a Generator by propagating the initial seed. import org.scalacheck.Gen import org.scalacheck.rng.Seed sealed trait Coin case object Head extends Coin case object Tail extends Coin def coinGen(rc: RandomContext): Generator[Coin] = OptionalValueGenerator( name = \"a Coin\", gen = () ⇒ { val nextSeed = rc.nextLong() val params = Gen.Parameters.default.withInitialSeed(nextSeed) val coin = Gen.oneOf[Coin](Head, Tail) coin(params, Seed(nextSeed)) } )"
    } ,    
    {
      "title": "Home",
      "url": "/cornichon/",
      "content": "Overview How does it look like? Find below an example of testing the Open Movie Database API. import com.github.agourlay.cornichon.CornichonFeature class ReadmeExample extends CornichonFeature { def feature = Feature(\"OpenMovieDatabase API\"){ Scenario(\"list GOT season 1 episodes\"){ When I get(\"http://www.omdbapi.com\").withParams( \"t\" -&gt; \"Game of Thrones\", \"Season\" -&gt; \"1\" ) Then assert status.is(200) And assert body.ignoring(\"Episodes\", \"Response\").is( \"\"\" { \"Title\": \"Game of Thrones\", \"Season\": \"1\" } \"\"\") And assert body.path(\"Episodes\").is( \"\"\" | Title | Released | Episode | imdbRating | imdbID | | \"Winter Is Coming\" | \"2011-04-17\" | \"1\" | \"8.1\" | \"tt1480055\" | | \"The Kingsroad\" | \"2011-04-24\" | \"2\" | \"7.8\" | \"tt1668746\" | | \"Lord Snow\" | \"2011-05-01\" | \"3\" | \"7.6\" | \"tt1829962\" | | \"Cripples, Bastards, and Broken Things\" | \"2011-05-08\" | \"4\" | \"7.7\" | \"tt1829963\" | | \"The Wolf and the Lion\" | \"2011-05-15\" | \"5\" | \"8.0\" | \"tt1829964\" | | \"A Golden Crown\" | \"2011-05-22\" | \"6\" | \"8.1\" | \"tt1837862\" | | \"You Win or You Die\" | \"2011-05-29\" | \"7\" | \"8.1\" | \"tt1837863\" | | \"The Pointy End\" | \"2011-06-05\" | \"8\" | \"7.9\" | \"tt1837864\" | | \"Baelor\" | \"2011-06-12\" | \"9\" | \"8.6\" | \"tt1851398\" | | \"Fire and Blood\" | \"2011-06-19\" | \"10\" | \"8.4\" | \"tt1851397\" | \"\"\") And assert body.path(\"Episodes\").asArray.hasSize(10) And assert body.path(\"Episodes[0]\").is( \"\"\" { \"Title\": \"Winter Is Coming\", \"Released\": \"2011-04-17\", \"Episode\": \"1\", \"imdbRating\": \"8.1\", \"imdbID\": \"tt1480055\" } \"\"\") And assert body.path(\"Episodes[0].Released\").is(\"2011-04-17\") And assert body.path(\"Episodes[*].Released\").is( \"\"\" [ \"2011-04-17\", \"2011-04-24\", \"2011-05-01\", \"2011-05-08\", \"2011-05-15\", \"2011-05-22\", \"2011-05-29\", \"2011-06-05\", \"2011-06-12\", \"2011-06-19\" ] \"\"\") And assert body.path(\"Episodes\").asArray.contains( \"\"\" { \"Title\": \"Winter Is Coming\", \"Released\": \"2011-04-17\", \"Episode\": \"1\", \"imdbRating\": \"8.1\", \"imdbID\": \"tt1480055\" } \"\"\") } } } For more examples see the following files which are part of the test pipeline: Embedded Superheroes API. OpenMovieDatabase API. DeckOfCard API. Star Wars API. Math Operations. And if you enjoy slides, you might like this presentation given at the Berlin Scala User Group which gives more context regarding the creation and usage of this library. License Cornichon is licensed under the Apache License, Version 2.0 (the “License”); you may not use this software except in compliance with the License. Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
    } ,    
    {
      "title": "Installation",
      "url": "/cornichon/installation.html",
      "content": "Installation Cornichon is available for Scala 2.12 &amp; Scala 2.13. The library is compatible with SBT and Mill. // SBT libraryDependencies += \"com.github.agourlay\" %% \"cornichon-test-framework\" % \"0.20.3\" % Test testFrameworks += new TestFramework(\"com.github.agourlay.cornichon.framework.CornichonFramework\") // Mill object test extends Tests { def ivyDeps = Agg(ivy\"com.github.agourlay::cornichon-test-framework:0.20.3\") def testFrameworks = Seq(\"com.github.agourlay.cornichon.framework.CornichonFramework\") }"
    } ,    
    {
      "title": "JSON matchers",
      "url": "/cornichon/json-matchers.html",
      "content": "JSON matchers If the exact value of a field is unknown, you can use JSON matchers to make sure it has a certain property or shape. JSON matchers work more or less like placeholders in practice. And assert body.ignoring(\"city\", \"realName\", \"publisher.location\").is( \"\"\" { \"name\": \"&lt;favorite-superhero&gt;\", \"hasSuperpowers\": *any-boolean*, \"publisher\": { \"name\": *any-string*, \"foundationYear\": *any-positive-integer* } } \"\"\" ) You just need to replace the value of the field by one of the built-in JSON matchers without quotes. Here are the available matchers: *is-present* : checks if the field is defined *is-null* : checks if the field is null *any-string* : checks if the field is a String *any-array* : checks if the field is an Array *any-object* : checks if the field is an Object *any-integer* : checks if the field is an Integer *any-positive-integer* : checks if the field is a positive Integer *any-negative-integer* : checks if the field is a negative Integer *any-uuid* : checks if the field is a valid UUID *any-boolean* : checks if the field is a boolean *any-alphanum-string* : checks if the field is an alphanumeric String *any-date* : checks if the field is a ‘yyyy-MM-dd’ date *any-date-time* : checks if the field is a ‘yyyy-MM-dd’T’HH:mm:ss.SSS’Z’’ datetime *any-time* : checks if the field is a ‘HH:mm:ss.SSS’ time This feature is still fresh and under experimentation therefore it comes with a couple of limitations: it is not yet possible to register custom JSON matchers matchers are not supported for JSON arrays assertions via asArray"
    } ,    
    {
      "title": "Misc.",
      "url": "/cornichon/misc.html",
      "content": "Custom HTTP body type By default, the HTTP DSL expects a String body but in some cases you might want to work at a higher level of abstraction. In order to use a custom type as body, it is necessary to provide 3 typeclass instances: cats.Show used to print the values io.circe.Encoder used to convert the values to JSON com.github.agourlay.cornichon.resolver.Resolvable used to provide a custom String representation in which placeholders can be resolved For instance if you wish to use the JsObject from play-json as HTTP request’s body you can define the following instances in your code: lazy implicit val jsonResolvableForm = new Resolvable[JsObject] { override def toResolvableForm(s: JsObject) = s.toString() override def fromResolvableForm(s: String) = Json.parse(s).as[JsObject] } lazy implicit val showJson = new Show[JsObject] { override def show(f: JsObject): String = f.toString() } lazy implicit val JsonEncoder:Encoder[JsObject] = new Encoder[JsObject] { override def apply(a: JsObject): Json = parse(a.toString()).getOrElse(cJson.Null) } SBT integration It is recommended to use the nice CLI from SBT to trigger tests: ~test tilde to re-run a command on change. testOnly *CornichonExamplesSpec to run only the feature CornichonExamplesSpec. testOnly *CornichonExamplesSpec -- \"Cornichon feature example should CRUD Feature demo\" to run only the scenario CRUD Feature demo from the feature Cornichon feature example. The full name of a scenario is feature-name should scenario-name. See SBT doc for more information. The steps execution logs will only be shown if: the scenario fails the scenario succeeded and contains at least one DebugStep such as And I show_last_status Running tests without a build tool When integrating cornichon features in a build pipeline, it can be interesting to package those features into a runnable forms to avoid the cost of recompilation. The library ships a main runner that can be used to run the tests without build tool. It can be found as com.github.agourlay.cornichon.framework.MainRunner. Once your project is packaged as a jar file, calling the main runner with --help shows the following info: Usage: cornichon-test-framework --packageToScan &lt;string&gt; [--featureParallelism &lt;integer&gt;] [--seed &lt;integer&gt;] [--scenarioNameFilter &lt;string&gt;] Run your cornichon features without SBT. Options and flags: --help Display this help text. --packageToScan &lt;string&gt; Package containing the feature files. --reportsOutputDir &lt;string&gt; Output directory for junit.xml files (default to current). --featureParallelism &lt;integer&gt; Number of feature running in parallel (default=1). --seed &lt;integer&gt; Seed to use for starting random processes. --scenarioNameFilter &lt;string&gt; Filter scenario to run by name. Packaging features in a Docker container You can find below an example of Docker packaging done using sbt-native-packager. You can place these settings in a docker.sbt in the root of your project. This should hopefully inspire you to set up your own solution or contribute to improve this one. import NativePackagerHelper._ lazy val root = (project in file(\".\")) .enablePlugins(JavaAppPackaging, DockerPlugin) .settings( testFrameworks += new TestFramework(\"com.github.agourlay.cornichon.framework.CornichonFramework\"), mainClass in Compile := Some(\"com.github.agourlay.cornichon.framework.MainRunner\"), scriptClasspath ++= { fromClasspath((managedClasspath in Test).value, \".\", _ =&gt; true).map(_._2) :+ (sbt.Keys.`package` in Test).value.getName }, mappings in Universal ++= { val testJar = (sbt.Keys.`package` in Test).value fromClasspath((managedClasspath in Test).value, \"lib\", _ =&gt; true) :+ (testJar -&gt; s\"lib/${testJar.getName}\") }, noPackageDoc, dockerCmd := Seq( \"--packageToScan=$your-root-package\", \"--reportsOutputDir=/target/test-reports\" ) ) After you created the docker.sbt, just run sbt docker:publishLocal in order to create a docker image locally."
    } ,    
    {
      "title": "Kafka integration",
      "url": "/cornichon/modules/module-kafka.html",
      "content": "Kafka integration cornichon-kafka offers a support for Kafka v2.0.0 The kafka client is shared at the feature level by all the scenarios and is configured with a fixed group-id to ‘cornichon-groupId’ and is set with offset-reset to ‘earliest’. Due to the architecture of kafka and the handling of consumers offsets, the default execution of scenarios is sequential. Comprehensive example import com.github.agourlay.cornichon.CornichonFeature import com.github.agourlay.cornichon.kafka.KafkaDsl class KafkaExample extends CornichonFeature with KafkaDsl { override lazy val kafkaBootstrapServersHost: String = \"localhost\" override lazy val kafkaBootstrapServersPort: Int = 9092 def feature = Feature(\"Kafka DSL\") { Scenario(\"Can write and read arbitrary Strings to/from topic\") { Given I put_topic( topic = \"cornichon\", key = \"success\", message = \"I am a plain string\" ) When I read_from_topic( topic = \"cornichon\", timeoutMs = 200, atLeastAmount = 1 ) Then assert kafka(\"cornichon\").topic_is(\"cornichon\") Then assert kafka(\"cornichon\").key_is(\"success\") Then assert kafka(\"cornichon\").message_value.is(\"I am a plain string\") } Scenario(\"Can use cornichon jsonAssertions on the message value\") { Given I put_topic( topic = \"cornichon\", key = \"json\", message = \"\"\"{ \"coffee\": \"black\", \"cornichon\": \"green\"}\"\"\" ) When I read_from_topic(\"cornichon\") Then assert kafka(\"cornichon\").topic_is(\"json\") Then assert kafka(\"cornichon\").message_value.ignoring(\"coffee\").is(\"\"\" { \"cornichon\": \"green\" } \"\"\" ) } } } Note that this dsl always return the latest amount of messages found on the topic. The consumer polls timeoutMs until it does not find any new messages anymore"
    } ,    
    {
      "title": "HTTP mock",
      "url": "/cornichon/modules/module-mock.html",
      "content": "HTTP Mock cornichon-http-mock contains the ListenTo DSL and infrastructure to build tests relying on mocked endpoints. Scenario(\"reply to POST request with 201 and assert on received bodies\") { HttpMock(\"awesome-server\") { When I post(\"&lt;awesome-server-url&gt;/heroes/batman\").withBody( \"\"\" { \"name\": \"Batman\", \"realName\": \"Bruce Wayne\", \"hasSuperpowers\": false } \"\"\" ) When I post(\"&lt;awesome-server-url&gt;/heroes/superman\").withBody( \"\"\" { \"name\": \"Superman\", \"realName\": \"Clark Kent\", \"hasSuperpowers\": true } \"\"\" ) Then assert status.is(201) // HTTP Mock exposes what it received When I get(\"&lt;awesome-server-url&gt;/requests-received\") Then assert body.asArray.ignoringEach(\"headers\").is( \"\"\" [ { \"body\" : { \"name\" : \"Batman\", \"realName\" : \"Bruce Wayne\", \"hasSuperpowers\" : false }, \"url\" : \"/heroes/batman\", \"method\" : \"POST\", \"parameters\" : {} }, { \"body\" : { \"name\" : \"Superman\", \"realName\" : \"Clark Kent\", \"hasSuperpowers\" : true }, \"url\" : \"/heroes/superman\", \"method\" : \"POST\", \"parameters\" : {} } ] \"\"\" ) } // Once HTTP Mock closed, the recorded requests are dumped in the session And assert httpListen(\"awesome-server\").received_calls(2) And assert httpListen(\"awesome-server\").received_requests.asArray.ignoringEach(\"headers\").is( \"\"\" [ { \"body\" : { \"name\" : \"Batman\", \"realName\" : \"Bruce Wayne\", \"hasSuperpowers\" : false }, \"url\" : \"/heroes/batman\", \"method\" : \"POST\", \"parameters\" : {} }, { \"body\" : { \"name\" : \"Superman\", \"realName\" : \"Clark Kent\", \"hasSuperpowers\" : true }, \"url\" : \"/heroes/superman\", \"method\" : \"POST\", \"parameters\" : {} } ] \"\"\" ) And assert httpListen(\"awesome-server\").received_requests.path(\"$[0].body.name\").is(\"Batman\") And assert httpListen(\"awesome-server\").received_requests.path(\"$[1].body\").is( \"\"\" { \"name\": \"Superman\", \"realName\": \"Clark Kent\", \"hasSuperpowers\": true } \"\"\" ) }"
    } ,    
    {
      "title": "Modules",
      "url": "/cornichon/modules.html",
      "content": "Modules Various additional modules are available and offer a set of features which do not fit in the core domain of the library. HTTP mock Kafka integration"
    } ,      
    {
      "title": "Placeholders",
      "url": "/cornichon/placeholders.html",
      "content": "Placeholders Most built-in steps can use placeholders in their arguments, those will be automatically resolved from the session: URL Expected body HTTP params (name and value) HTTP headers (name and value) JSON Path import com.github.agourlay.cornichon.CornichonFeature class PlaceholderFeature extends CornichonFeature { def feature = Feature(\"Placeholders examples\") { Scenario(\"abstract favorite superheroes\") { Given I save(\"favorite-superhero\" -&gt; \"Batman\") Then assert session_value(\"favorite-superhero\").is(\"Batman\") When I get(\"http://localhost:8080/superheroes/&lt;favorite-superhero&gt;\") Then assert body.is( \"\"\" { \"name\": \"&lt;favorite-superhero&gt;\", \"realName\": \"Bruce Wayne\", \"city\": \"Gotham city\", \"publisher\": \"DC\" } \"\"\" ) And I save_body_path(\"city\" -&gt; \"batman-city\") Then assert session_value(\"batman-city\").is(\"Gotham city\") Then assert body.is( \"\"\" { \"name\": \"&lt;favorite-superhero&gt;\", \"realName\": \"Bruce Wayne\", \"city\": \"&lt;batman-city&gt;\", \"publisher\": \"DC\" } \"\"\" ) } } } It is also possible to inject random values inside placeholders using: &lt;random-uuid&gt; for a random UUID &lt;random-positive-integer&gt; for a random Integer between 0-10000 &lt;random-string&gt; for a random String of length 5 &lt;random-alphanum-string&gt; for a random alphanumeric String of length 5 &lt;random-boolean&gt; for a random Boolean string &lt;random-timestamp&gt; for a random timestamp &lt;current-timestamp&gt; for the current timestamp &lt;scenario-unique-number&gt; for a unique number scoped per scenario &lt;global-unique-number&gt; for a globally unique number across all features post(\"http://url.io/somethingWithAnId\").withBody( \"\"\" { \"id\" : \"&lt;random-uuid&gt;\" } \"\"\") If you save several times a value under the same key, the session will behave like a Multimap by appending the values. It becomes then possible to retrieve past values : &lt;name&gt; always uses the latest value taken by the key. &lt;name[0]&gt; uses the first value taken by the key &lt;name[1]&gt; uses the second element taken by the key"
    } ,    
    {
      "title": "PBT",
      "url": "/cornichon/property-based-testing.html",
      "content": "Property based testing support Cornichon offers support for Property based testing via two different flavours of testing, ForAll &amp; random model exploration."
    } ,    
    {
      "title": "Random model exploration",
      "url": "/cornichon/pbt/random-model-exploration.html",
      "content": "Random model exploration The initial inspiration came after reading the following article Property based integration testing using Haskell! which describes a way to tackle the problem of property based testing for HTTP APIs. It is still a great introduction to the problem we are trying to solve, although the implementations are significantly different. Concepts Performing property based testing of a pure function is quite easy, for all possible values, check that a given invariant is valid. In the case of an HTTP API, it is more difficult to perform such operations, you are more often than not testing that a set of invariants are valid throughout a workflow. The key idea is to describe the possible interactions with the API as Markov chains which can be automatically explored. The entry point for random model exploration is the following function in the DSL: def check_model[A, B, C, D, E, F](maxNumberOfRuns: Int, maxNumberOfTransitions: Int)(modelRunner: ModelRunner[A, B, C, D, E, F]) Let’s unpack this signature: maxNumberOfRuns refers to maximum number of attempt to traverse the Markov chain and find a case that breaks an invariant maxNumberOfTransition is useful when the model contains cycles in order to ensure termination modelRunner is the actual definition of the model A B C D E F refers to the types of the generators used in model definition (maximum of 6 for the moment) Such a Markov chain wires together a set of properties that relate to each other through transitions which are chosen according to a given probability (between 0 and 100). A property is composed of: a description an optional pre-condition which is a step checking that the property can be run (sometimes useful to target error cases) an invariant which is a function from a number of generators to a step performing whatever side effect and assertions necessary The number of generators is defined in the property type: Property0 an action which accepts a function from () =&gt; Step Property1[A] an action which accepts a function from () ⇒ A =&gt; Step Property2[A, B] an action which accepts a function from (() ⇒ A, () =&gt; B) =&gt; Step Property3[A, B, C] an action which accepts a function from (() ⇒ A, () =&gt; B, () =&gt; C) =&gt; Step up to Property6[A, B, C, D, E, F] It is of course not required to call a generator when building a Step. However, it is required to have the same Property type for all properties within a model definition. Having generators as input enables the action to introduce some randomness in its effect. A run terminates successfully if the max number of transition reached, this means we were not able to break any invariants. A run fails if one of the following conditions is met: an error is thrown from a property no properties with a valid pre-condition can be found, this is generally a sign of a malformed model a generator throws an error A model exploration terminates successfully if the max number of runs is reached or with an error if a run fails. Let’s create our first model! It will be a basic chain which will not enforce any invariants; it will have: an entry point a ping property printing a random String a pong property printing a random Int an exit point We will define the transitions such that: there is a 50% chance to start with ping or pong following the entry point there is 90% to go from a ping/pong to a pong/ping there is no loop from any property there is a 10% chance to exit the game after a ping or a pong Also, the DSL is asking for a modelRunner which is a little helper connecting a model to its generators. The type inference is sometimes not properly detecting the action type, so it is recommended to define the modelRunner and the model as a single expression to help the typechecker. def stringGen(rc: RandomContext): ValueGenerator[String] = ValueGenerator( name = \"an alphanumeric String\", gen = () ⇒ rc.alphanumeric.take(20).mkString(\"\")) def integerGen(rc: RandomContext): ValueGenerator[Int] = ValueGenerator( name = \"integer\", gen = () ⇒ rc.nextInt(10000)) val myModelRunner = ModelRunner.make[String, Int](stringGen, integerGen) { val entryPoint = Property2[String, Int]( description = \"Entry point\", invariant = (_, _) ⇒ print_step(\"Start game\") ) val pingString = Property2[String, Int]( description = \"Ping String\", invariant = (stringGen, _) ⇒ print_step(s\"Ping ${stringGen()}\") ) val pongInt = Property2[String, Int]( description = \"Pong Int\", invariant = (_, intGen) ⇒ print_step(s\"Pong ${intGen()}\") ) val exitPoint = Property2[String, Int]( description = \"Exit point\", invariant = (_, _) ⇒ print_step(\"End of game\") ) Model( description = \"ping pong model\", entryPoint = entryPoint, transitions = Map( entryPoint -&gt; ((50, pingString) :: (50, pongInt) :: Nil), pingString -&gt; ((90, pongInt) :: (10, exitPoint) :: Nil), pongInt -&gt; ((90, pingString) :: (10, exitPoint) :: Nil) ) ) } Which gives us the following scenario Scenario(\"ping pong check\") { Given I check_model(maxNumberOfRuns = 2, maxNumberOfTransitions = 10)(myModelRunner) } Running this scenario outputs: Starting scenario 'ping pong check' - ping pong check (10 millis) Scenario : ping pong check main steps Checking model 'ping pong model' with maxNumberOfRuns=2 and maxNumberOfTransitions=10 and seed=1542986106586 Run #1 Entry point Start game Ping String Ping 7HjRBzlyjULWQlV1SQeN Pong Int Pong 3549 Ping String Ping SbL4blEMtwweAqm9bfP0 Pong Int Pong 1464 Ping String Ping BoZwLouAaXVayxXajSXV Pong Int Pong 161 Ping String Ping BOCm8OyLL2zgpPCoYnTJ Pong Int Pong 687 Ping String Ping d9ZRN1HuBhVwFKXBzlUh Pong Int Pong 1892 Run #1 - Max transitions number per run reached Run #2 Entry point Start game Ping String Ping oHARiIS8570hOHbkpu6b Pong Int Pong 743 Ping String Ping Ijq1xltbS2fGIVJ0h3ty Pong Int Pong 7575 Ping String Ping 15DDNEIATOrbKnDQi9QI Pong Int Pong 4674 Ping String Ping YNvchmkwK7owS95YeyXr Pong Int Pong 3758 Ping String Ping DavIeJhxwOpgmqXZrzOU Exit point End of game Run #2 - End reached on property 'Exit point' after 10 transitions Check block succeeded (10 millis) The logs give us: a detailed description of the runs execution the seed used to create the Generators It is possible to replay exactly the same run by passing the seed as a parameter of the feature or by a CLI argument. Examples Now that we have a better understanding of the concepts and their semantics, it is time to dive into some concrete examples! Having cornichon freely explore the transitions of a model can create some interesting configurations. Turnstile In this example we are going to test an HTTP API implementing a basic turnstile. This is a rotating gate that let people pass one at the time after payment. In our simplified model it is not possible to pay for several people to pass in advance. The server exposes two endpoints: a POST request on /push-coin to unlock the gate a POST request on /walk-through to turn the gate import com.github.agourlay.cornichon.CornichonFeature import com.github.agourlay.cornichon.steps.check.checkModel._ class TurnstileCheck extends CornichonFeature { def feature = Feature(\"Basic examples of checks\") { Scenario(\"Turnstile acts according to model\") { Given I check_model(maxNumberOfRuns = 1, maxNumberOfTransitions = 10)(turnstileModel) } } //Model definition usually in another trait private val pushCoin = Property0( description = \"push a coin\", invariant = () =&gt; Attach { Given I post(\"/push-coin\") Then assert status.is(200) And assert body.is(\"payment accepted\") }) private val pushCoinBlocked = Property0( description = \"push a coin is a blocked\", invariant = () =&gt; Attach { Given I post(\"/push-coin\") Then assert status.is(400) And assert body.is(\"payment refused\") }) private val walkThroughOk = Property0( description = \"walk through ok\", invariant = () =&gt; Attach { Given I post(\"/walk-through\") Then assert status.is(200) And assert body.is(\"door turns\") }) private val walkThroughBlocked = Property0( description = \"walk through blocked\", invariant = () =&gt; Attach { Given I post(\"/walk-through\") Then assert status.is(400) And assert body.is(\"door blocked\") }) val turnstileModel = ModelRunner.makeNoGen( Model( description = \"Turnstile acts according to model\", entryPoint = pushCoin, transitions = Map( pushCoin -&gt; ((90, walkThroughOk) :: (10, pushCoinBlocked) :: Nil), pushCoinBlocked -&gt; ((90, walkThroughOk) :: (10, pushCoinBlocked) :: Nil), walkThroughOk -&gt; ((70, pushCoin) :: (30, walkThroughBlocked) :: Nil), walkThroughBlocked -&gt; ((90, pushCoin) :: (10, walkThroughBlocked) :: Nil) ) ) ) } Again let’s have a look at the logs to see how things go. Starting scenario 'Turnstile acts according to model' - Turnstile acts according to model (55 millis) Scenario : Turnstile acts according to model main steps Checking model 'Turnstile acts according to model' with maxNumberOfRuns=1 and maxNumberOfTransitions=10 and seed=1542021399582 Run #1 push a coin Given I POST /push-coin (9 millis) Then assert status is '200' (0 millis) And assert response body is payment accepted (0 millis) push a coin is a blocked Given I POST /push-coin (5 millis) Then assert status is '400' (0 millis) And assert response body is payment refused (0 millis) walk through ok Given I POST /walk-through (3 millis) Then assert status is '200' (0 millis) And assert response body is door turns (0 millis) push a coin Given I POST /push-coin (3 millis) Then assert status is '200' (0 millis) And assert response body is payment accepted (0 millis) walk through ok Given I POST /walk-through (3 millis) Then assert status is '200' (0 millis) And assert response body is door turns (0 millis) walk through blocked Given I POST /walk-through (3 millis) Then assert status is '400' (0 millis) And assert response body is door blocked (0 millis) push a coin Given I POST /push-coin (3 millis) Then assert status is '200' (0 millis) And assert response body is payment accepted (0 millis) walk through ok Given I POST /walk-through (3 millis) Then assert status is '200' (0 millis) And assert response body is door turns (0 millis) push a coin Given I POST /push-coin (3 millis) Then assert status is '200' (0 millis) And assert response body is payment accepted (0 millis) walk through ok Given I POST /walk-through (3 millis) Then assert status is '200' (0 millis) And assert response body is door turns (0 millis) push a coin Given I POST /push-coin (3 millis) Then assert status is '200' (0 millis) And assert response body is payment accepted (0 millis) Run #1 - Max transitions number per run reached Check block succeeded (54 millis) It is interesting to note that we are executing a single run on purpose, as the server is stateful, any subsequent runs would share the global state of the turnstile. This is an issue because we are starting our model with pushCoinAction which is always expected to succeed. Let’s try to test the same model with more runs to see if it breaks! Starting scenario 'Turnstile acts according to model' - **failed** Turnstile acts according to model (74 millis) Scenario 'Turnstile acts according to model' failed: at step: Then assert status is '200' with error(s): expected status code '200' but '400' was received with body: \"payment refused\" and with headers: 'Date' -&gt; 'Mon, 12 Nov 2018 11:18:03 GMT' replay only this scenario with the command: testOnly *TurnstileCheck -- \"Turnstile acts according to model\" Scenario : Turnstile acts according to model main steps Checking model 'Turnstile acts according to model' with maxNumberOfRuns=2 and maxNumberOfTransitions=10 and seed=1542021482941 Run #1 push a coin Given I POST /push-coin (11 millis) Then assert status is '200' (0 millis) And assert response body is payment accepted (0 millis) walk through ok Given I POST /walk-through (4 millis) Then assert status is '200' (0 millis) And assert response body is door turns (0 millis) push a coin Given I POST /push-coin (3 millis) Then assert status is '200' (0 millis) And assert response body is payment accepted (0 millis) walk through ok Given I POST /walk-through (3 millis) Then assert status is '200' (0 millis) And assert response body is door turns (0 millis) push a coin Given I POST /push-coin (4 millis) Then assert status is '200' (0 millis) And assert response body is payment accepted (0 millis) walk through ok Given I POST /walk-through (3 millis) Then assert status is '200' (0 millis) And assert response body is door turns (0 millis) push a coin Given I POST /push-coin (3 millis) Then assert status is '200' (0 millis) And assert response body is payment accepted (0 millis) walk through ok Given I POST /walk-through (3 millis) Then assert status is '200' (0 millis) And assert response body is door turns (0 millis) push a coin Given I POST /push-coin (3 millis) Then assert status is '200' (0 millis) And assert response body is payment accepted (0 millis) walk through ok Given I POST /walk-through (3 millis) Then assert status is '200' (0 millis) And assert response body is door turns (0 millis) push a coin Given I POST /push-coin (3 millis) Then assert status is '200' (0 millis) And assert response body is payment accepted (0 millis) Run #1 - Max transitions number per run reached Run #2 push a coin Given I POST /push-coin (3 millis) Then assert status is '200' *** FAILED *** expected status code '200' but '400' was received with body: \"payment refused\" and with headers: 'Date' -&gt; 'Mon, 12 Nov 2018 11:18:03 GMT' Run #2 - Failed Check model block failed (74 millis) Using 2 runs, we already found the problem because the first run finished by introducing a coin. It is possible to replay exactly this run in a deterministic fashion by using the seed printed in the logs and feed it to the DSL. Given I check_model(maxNumberOfRuns = 2, maxNumberOfTransitions = 10)(turnstileModel) This example shows that designing property based scenarios is sometimes challenging in the case of shared mutable states. The source for the test and the server are available here. Web shop Admin (advanced example) In this example we are going to test an HTTP API implementing a basic web shop. This web shop offers the possibility to CRUD products and to search them via an index that is eventually consistent. A product is defined by the following case class. case class Product(id: UUID, name: String, description: String, price: BigInt) case class ProductDraft(name: String, description: String, price: BigInt) The server exposes the following endpoint: a POST request on /products to create a product via productDraft a POST request on /products/&lt;id&gt; to update a product a DELETE request on /products/&lt;id&gt; to delete a product a GET request on /products to get all products a GET request on /products/&lt;id&gt; to get a single product a GET request on products-search to get all the products in the search index The contract is that the consistency delay should always be under 10 seconds for all operations being mirrored in the search index. Let’s see if we can test it! package com.github.agourlay.cornichon.check.examples.webShop class WebShopCheck extends CornichonFeature { def feature = Feature(\"Advanced example of model checks\") { Scenario(\"WebShop acts according to model\") { Given I check_model(maxNumberOfRuns = 1, maxNumberOfTransitions = 5)(webShopModel) } } val maxIndexSyncTimeout = 10.seconds def productDraftGen(rc: RandomContext): Generator[ProductDraft] = OptionalValueGenerator( name = \"a product draft\", gen = () ⇒ { val nextSeed = rc.nextLong() val params = Gen.Parameters.default.withInitialSeed(nextSeed) val gen = for { name ← Gen.alphaStr description ← Gen.alphaStr price ← Gen.choose(1, Int.MaxValue) } yield ProductDraft(name, description, price) gen(params, Seed(nextSeed)) } ) private val noProductsInDb = Property1[ProductDraft]( description = \"no products in DB\", invariant = _ ⇒ Attach { Given I get(\"/products\") Then assert status.is(200) Then assert body.asArray.isEmpty } ) private val createProduct = Property1[ProductDraft]( description = \"create a product\", invariant = pd ⇒ { val productDraft = pd() val productDraftJson = productDraft.asJson Attach { Given I post(\"/products\").withBody(productDraftJson) Then assert status.is(201) And assert body.ignoring(\"id\").is(productDraftJson) Eventually(maxDuration = maxIndexSyncTimeout, interval = 10.millis) { When I get(\"/products-search\") Then assert status.is(200) And assert body.asArray.ignoringEach(\"id\").contains(productDraftJson) } } }) private val deleteProduct = Property1[ProductDraft]( description = \"delete a product\", preCondition = Attach { Given I get(\"/products\") Then assert body.asArray.isNotEmpty }, invariant = _ ⇒ Attach { Given I get(\"/products\") Then assert status.is(200) Then I save_body_path(\"$[0].id\" -&gt; \"id-to-delete\") Given I delete(\"/products/&lt;id-to-delete&gt;\") Then assert status.is(200) And I get(\"/products/&lt;id-to-delete&gt;\") Then assert status.is(404) Eventually(maxDuration = maxIndexSyncTimeout, interval = 10.millis) { When I get(\"/products-search\") Then assert status.is(200) And assert body.path(\"$[*].id\").asArray.not_contains(\"&lt;id-to-delete&gt;\") } } ) private val updateProduct = Property1[ProductDraft]( description = \"update a product\", preCondition = Attach { Given I get(\"/products\") Then assert body.asArray.isNotEmpty }, invariant = pd ⇒ { val productDraft = pd() val productDraftJson = productDraft.asJson Attach { Given I get(\"/products\") Then assert status.is(200) Then I save_body_path(\"$[0].id\" -&gt; \"id-to-update\") Given I post(\"/products/&lt;id-to-update&gt;\").withBody(productDraftJson) Then assert status.is(201) And I get(\"/products/&lt;id-to-update&gt;\") Then assert status.is(200) And assert body.ignoring(\"id\").is(productDraftJson) Eventually(maxDuration = maxIndexSyncTimeout, interval = 10.millis) { When I get(\"/products-search\") Then assert status.is(200) And assert body.asArray.ignoringEach(\"id\").contains(productDraftJson) } } } ) val webShopModel = ModelRunner.make[ProductDraft](productDraftGen)( Model( description = \"WebShop acts according to specification\", entryPoint = noProductsInDb, transitions = Map( noProductsInDb -&gt; ((100, createProduct) :: Nil), createProduct -&gt; ((60, createProduct) :: (30, updateProduct) :: (10, deleteProduct) :: Nil), deleteProduct -&gt; ((60, createProduct) :: (30, updateProduct) :: (10, deleteProduct) :: Nil), updateProduct -&gt; ((60, createProduct) :: (30, updateProduct) :: (10, deleteProduct) :: Nil) ) ) ) } Again, let’s have a look at the logs to see how things go. Advanced example of model checks: Starting scenario 'WebShop acts according to model' - WebShop acts according to model (42747 millis) Scenario : WebShop acts according to model main steps Checking model 'WebShop acts according to specification' with maxNumberOfRuns=1 and maxNumberOfTransitions=5 and seed=1544540492543 Run #1 no products in DB Given I GET /products (1328 millis) Then assert status is '200' (10 millis) Then assert response body array size is '0' (15 millis) create a product Given I POST /products with body (59 millis) { \"name\" : \"rzdikphaxkjroaoYguPblwnwxdnnnrokkjhscTfmwfanhrsXsamphz\", \"description\" : \"flaukuIykZksgwsxznkayAiiojwgndtiffT\", \"price\" : 32 } Then assert status is '201' (0 millis) And assert response body is (41 millis) { \"name\" : \"rzdikphaxkjroaoYguPblwnwxdnnnrokkjhscTfmwfanhrsXsamphz\", \"description\" : \"flaukuIykZksgwsxznkayAiiojwgndtiffT\", \"price\" : 32 } ignoring keys id Eventually block with maxDuration = 10 seconds and interval = 10 milliseconds When I GET /products-search (9 millis) Then assert status is '200' (0 millis) And assert response body array contains { \"name\" : \"rzdikphaxkjroaoYguPblwnwxdnnnrokkjhscTfmwfanhrsXsamphz\", \"description\" : \"flaukuIykZksgwsxznkayAiiojwgndtiffT\", \"price\" : 32 } *** FAILED *** expected array to contain '{ \"name\" : \"rzdikphaxkjroaoYguPblwnwxdnnnrokkjhscTfmwfanhrsXsamphz\", \"description\" : \"flaukuIykZksgwsxznkayAiiojwgndtiffT\", \"price\" : 32 }' but it is not the case with array: [ ] When I GET /products-search (5 millis) Then assert status is '200' (0 millis) And assert response body array contains (0 millis) { \"name\" : \"rzdikphaxkjroaoYguPblwnwxdnnnrokkjhscTfmwfanhrsXsamphz\", \"description\" : \"flaukuIykZksgwsxznkayAiiojwgndtiffT\", \"price\" : 32 } Eventually block succeeded after '552' retries with '1' distinct errors (8972 millis) update a product Given I GET /products (2 millis) Then assert status is '200' (0 millis) Then I save path '$[0].id' from body to key 'id-to-update' (8 millis) Given I POST /products/ee668765-b274-462d-ace8-73e2464286ca with body (11 millis) { \"name\" : \"usogcaoeNkEgmaqybjpoisbtizlFkNyyrvvgCtbwoxdzxijwwdugmJZeksdBFbvcXn\", \"description\" : \"wflinKgfiguhNjkhwepgsdUmylbrXsjvhEnUccHzqglrpaiksaEtlbgmhfocAWjvieTwva\", \"price\" : 46 } Then assert status is '201' (0 millis) And I GET /products/ee668765-b274-462d-ace8-73e2464286ca (6 millis) Then assert status is '200' (0 millis) And assert response body is (0 millis) { \"name\" : \"usogcaoeNkEgmaqybjpoisbtizlFkNyyrvvgCtbwoxdzxijwwdugmJZeksdBFbvcXn\", \"description\" : \"wflinKgfiguhNjkhwepgsdUmylbrXsjvhEnUccHzqglrpaiksaEtlbgmhfocAWjvieTwva\", \"price\" : 46 } ignoring keys id Eventually block with maxDuration = 10 seconds and interval = 10 milliseconds When I GET /products-search (2 millis) Then assert status is '200' (0 millis) And assert response body array contains { \"name\" : \"usogcaoeNkEgmaqybjpoisbtizlFkNyyrvvgCtbwoxdzxijwwdugmJZeksdBFbvcXn\", \"description\" : \"wflinKgfiguhNjkhwepgsdUmylbrXsjvhEnUccHzqglrpaiksaEtlbgmhfocAWjvieTwva\", \"price\" : 46 } *** FAILED *** expected array to contain '{ \"name\" : \"usogcaoeNkEgmaqybjpoisbtizlFkNyyrvvgCtbwoxdzxijwwdugmJZeksdBFbvcXn\", \"description\" : \"wflinKgfiguhNjkhwepgsdUmylbrXsjvhEnUccHzqglrpaiksaEtlbgmhfocAWjvieTwva\", \"price\" : 46 }' but it is not the case with array: [ { \"id\" : \"ee668765-b274-462d-ace8-73e2464286ca\", \"name\" : \"rzdikphaxkjroaoYguPblwnwxdnnnrokkjhscTfmwfanhrsXsamphz\", \"description\" : \"flaukuIykZksgwsxznkayAiiojwgndtiffT\", \"price\" : 32 } ] When I GET /products-search (2 millis) Then assert status is '200' (0 millis) And assert response body array contains (0 millis) { \"name\" : \"usogcaoeNkEgmaqybjpoisbtizlFkNyyrvvgCtbwoxdzxijwwdugmJZeksdBFbvcXn\", \"description\" : \"wflinKgfiguhNjkhwepgsdUmylbrXsjvhEnUccHzqglrpaiksaEtlbgmhfocAWjvieTwva\", \"price\" : 46 } Eventually block succeeded after '616' retries with '1' distinct errors (8996 millis) delete a product Given I GET /products (1 millis) Then assert status is '200' (0 millis) Then I save path '$[0].id' from body to key 'id-to-delete' (0 millis) Given I DELETE /products/ee668765-b274-462d-ace8-73e2464286ca (2 millis) Then assert status is '200' (0 millis) And I GET /products/ee668765-b274-462d-ace8-73e2464286ca (1 millis) Then assert status is '404' (0 millis) Eventually block with maxDuration = 10 seconds and interval = 10 milliseconds When I GET /products-search (1 millis) Then assert status is '200' (0 millis) And assert response body's array '$[*].id' does not contain ee668765-b274-462d-ace8-73e2464286ca *** FAILED *** expected array to not contain '\"ee668765-b274-462d-ace8-73e2464286ca\"' but it is not the case with array: [ \"ee668765-b274-462d-ace8-73e2464286ca\" ] When I GET /products-search (2 millis) Then assert status is '200' (0 millis) And assert response body's array '$[*].id' does not contain (0 millis) ee668765-b274-462d-ace8-73e2464286ca Eventually block succeeded after '571' retries with '1' distinct errors (8001 millis) create a product Given I POST /products with body (2 millis) { \"name\" : \"kskqbczgcepmzvoybdKmpniflncdWqbqejtLcj\", \"description\" : \"krrzzpmbwLyxsfiwxhdlnoycnfk\", \"price\" : 77 } Then assert status is '201' (0 millis) And assert response body is (0 millis) { \"name\" : \"kskqbczgcepmzvoybdKmpniflncdWqbqejtLcj\", \"description\" : \"krrzzpmbwLyxsfiwxhdlnoycnfk\", \"price\" : 77 } ignoring keys id Eventually block with maxDuration = 10 seconds and interval = 10 milliseconds When I GET /products-search (1 millis) Then assert status is '200' (0 millis) And assert response body array contains { \"name\" : \"kskqbczgcepmzvoybdKmpniflncdWqbqejtLcj\", \"description\" : \"krrzzpmbwLyxsfiwxhdlnoycnfk\", \"price\" : 77 } *** FAILED *** expected array to contain '{ \"name\" : \"kskqbczgcepmzvoybdKmpniflncdWqbqejtLcj\", \"description\" : \"krrzzpmbwLyxsfiwxhdlnoycnfk\", \"price\" : 77 }' but it is not the case with array: [ ] When I GET /products-search (1 millis) Then assert status is '200' (0 millis) And assert response body array contains (0 millis) { \"name\" : \"kskqbczgcepmzvoybdKmpniflncdWqbqejtLcj\", \"description\" : \"krrzzpmbwLyxsfiwxhdlnoycnfk\", \"price\" : 77 } Eventually block succeeded after '671' retries with '1' distinct errors (9003 millis) create a product Given I POST /products with body (2 millis) { \"name\" : \"mrhwfmp\", \"description\" : \"hBvcqpyatdyjccokfvXtbppejlSfnuGgmahAclfjCqmzCmdqydNsiYlICpZnwgqxzVkzrqnoyucZtbgoguc\", \"price\" : 18 } Then assert status is '201' (0 millis) And assert response body is (0 millis) { \"name\" : \"mrhwfmp\", \"description\" : \"hBvcqpyatdyjccokfvXtbppejlSfnuGgmahAclfjCqmzCmdqydNsiYlICpZnwgqxzVkzrqnoyucZtbgoguc\", \"price\" : 18 } ignoring keys id Eventually block with maxDuration = 10 seconds and interval = 10 milliseconds When I GET /products-search (0 millis) Then assert status is '200' (0 millis) And assert response body array contains { \"name\" : \"mrhwfmp\", \"description\" : \"hBvcqpyatdyjccokfvXtbppejlSfnuGgmahAclfjCqmzCmdqydNsiYlICpZnwgqxzVkzrqnoyucZtbgoguc\", \"price\" : 18 } *** FAILED *** expected array to contain '{ \"name\" : \"mrhwfmp\", \"description\" : \"hBvcqpyatdyjccokfvXtbppejlSfnuGgmahAclfjCqmzCmdqydNsiYlICpZnwgqxzVkzrqnoyucZtbgoguc\", \"price\" : 18 }' but it is not the case with array: [ { \"id\" : \"acd3425c-08cb-4cb0-be11-1d3e4611c1fa\", \"name\" : \"kskqbczgcepmzvoybdKmpniflncdWqbqejtLcj\", \"description\" : \"krrzzpmbwLyxsfiwxhdlnoycnfk\", \"price\" : 77 } ] When I GET /products-search (1 millis) Then assert status is '200' (0 millis) And assert response body array contains (0 millis) { \"name\" : \"mrhwfmp\", \"description\" : \"hBvcqpyatdyjccokfvXtbppejlSfnuGgmahAclfjCqmzCmdqydNsiYlICpZnwgqxzVkzrqnoyucZtbgoguc\", \"price\" : 18 } Eventually block succeeded after '463' retries with '1' distinct errors (6001 millis) Run #1 - Max transitions number per run reached Check block succeeded (42662 millis) We can see that we have been interacting with the CRUD API using randomly generated ProductDraft and that the eventually consistent contracts seem to hold. The source for the test and the server are available here. Caveats all properties must have the same types within a model definition the API has a few rough edges, especially regarding type inference for the modelRunner definition the max number of generators is hard-coded to 6"
    } ,    
    {
      "title": "Reference configuration",
      "url": "/cornichon/reference-configuration.html",
      "content": "Reference configuration It is possible to configure various aspects of the runs via a /src/test/resources/reference.conf file. You will find below the available keys and their respective default values. cornichon { requestTimeout = 2000 millis globalBaseUrl = \"\" executeScenariosInParallel = true scenarioExecutionParallelismFactor = 1 traceRequests = false warnOnDuplicateHeaders = false failOnDuplicateHeaders = false disableCertificateVerification = false followRedirect = false }"
    } ,    
    {
      "title": "Resource steps",
      "url": "/cornichon/custom-steps/resource-step.html",
      "content": "ScenarioResourceStep A ScenarioResourceStep is a way to acquire a resource / create some state and make sure it gets released / cleaned up at the end of the Scenario even if normal control flow is interrupted (by an error or a failed assertion for example). It can be implemented by a pair of Steps. One to acquire the resource and another to release it. Information can be communicated between the two steps the same way we would with any other Step, through the Session. So, for example, in a scenario containing: Given I setup_some_fixture_data() where def setup_some_fixture_data() = ScenarioResourceStep( title = \"Set up fixture data\" acquire = EffectStep(\"insert data\", { scenarioContext =&gt; val randomId = insertData() scenarioContext.session.addValue(\"id\", randomId) }), release = EffectStep(\"clean up data\", { scenarioContext =&gt; val randomId = scenarioContext.session.get(\"id\").right.get deleteData(randomId) }) ) we can be sure the clean up data step runs regardless of what happens after insert data. Multiple SenarioResourceSteps are allowed in a Scenario. In this case, the release Step of the last ScenarioResourceStep is run first, and we proceed up the Scenario."
    } ,      
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
